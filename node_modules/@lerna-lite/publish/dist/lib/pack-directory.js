"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packDirectory = void 0;
const path_1 = __importDefault(require("path"));
const npm_packlist_1 = __importDefault(require("npm-packlist"));
const npmlog_1 = __importDefault(require("npmlog"));
const tar_1 = __importDefault(require("tar"));
const core_1 = require("@lerna-lite/core");
const get_packed_1 = require("./get-packed");
/**
 * Pack a directory suitable for publishing, writing tarball to a tempfile.
 * @param {Package|string} _pkg Package instance or path to manifest
 * @param {string} dir to pack
 * @param {PackConfig} options
 */
function packDirectory(_pkg, dir, options) {
    const pkg = core_1.Package.lazy(_pkg, dir);
    const opts = {
        // @ts-ignore
        log: npmlog_1.default,
        ...options,
    };
    opts.log.verbose('pack-directory', path_1.default.relative('.', pkg.contents));
    let chain = Promise.resolve();
    if (opts.ignorePrepublish !== true) {
        chain = chain.then(() => (0, core_1.runLifecycle)(pkg, 'prepublish', opts));
    }
    chain = chain.then(() => (0, core_1.runLifecycle)(pkg, 'prepare', opts));
    if (opts.lernaCommand === 'publish') {
        opts.stdio = 'inherit';
        chain = chain.then(() => pkg.refresh());
        chain = chain.then(() => (0, core_1.runLifecycle)(pkg, 'prepublishOnly', opts));
        chain = chain.then(() => pkg.refresh());
    }
    chain = chain.then(() => (0, core_1.runLifecycle)(pkg, 'prepack', opts));
    chain = chain.then(() => pkg.refresh());
    chain = chain.then(() => (0, npm_packlist_1.default)({ path: pkg.contents }));
    chain = chain.then((files) => tar_1.default.create({
        cwd: pkg.contents,
        prefix: 'package/',
        portable: true,
        // Provide a specific date in the 1980s for the benefit of zip,
        // which is confounded by files dated at the Unix epoch 0.
        mtime: new Date('1985-10-26T08:15:00.000Z'),
        gzip: true,
    }, 
    // NOTE: node-tar does some Magic Stuff depending on prefixes for files
    //       specifically with @ signs, so we just neutralize that one
    //       and any such future 'features' by prepending `./`
    files.map((f) => `./${f}`)));
    chain = chain.then((stream) => (0, core_1.tempWrite)(stream, getTarballName(pkg)));
    chain = chain.then((tarFilePath) => (0, get_packed_1.getPacked)(pkg, tarFilePath).then((packed) => Promise.resolve()
        .then(() => (0, core_1.runLifecycle)(pkg, 'postpack', opts))
        .then(() => packed)));
    return chain;
}
exports.packDirectory = packDirectory;
function getTarballName(pkg) {
    const name = pkg.name[0] === '@'
        ? // scoped packages get special treatment
            pkg.name.substring(1).replace(/\//g, '-')
        : pkg.name;
    return `${name}-${pkg.version}.tgz`;
}
//# sourceMappingURL=pack-directory.js.map