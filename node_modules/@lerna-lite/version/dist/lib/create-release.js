"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRelease = exports.createReleaseClient = void 0;
const npmlog_1 = __importDefault(require("npmlog"));
const semver_1 = __importDefault(require("semver"));
const core_1 = require("@lerna-lite/core");
/**
 * @param {'github' | 'gitlab'} type
 */
function createReleaseClient(type) {
    switch (type) {
        case 'gitlab':
            return (0, core_1.createGitLabClient)();
        case 'github':
            return (0, core_1.createGitHubClient)();
        /* istanbul ignore next: guarded by yargs.choices() */
        default:
            throw new core_1.ValidationError('ERELEASE', 'Invalid release client type');
    }
}
exports.createReleaseClient = createReleaseClient;
/**
 * @param {ReturnType<typeof createReleaseClient>} client
 * @param {{ tags: string[]; releaseNotes: { name: string; notes: string; }[] }} commandProps
 * @param {{ gitRemote: string; execOpts: import('@lerna/child-process').ExecOpts }} opts
 */
function createRelease(client, { tags, releaseNotes }, { gitRemote, execOpts }, gitDryRun = false) {
    const repo = (0, core_1.parseGitRepo)(gitRemote, execOpts);
    return Promise.all(releaseNotes.map(({ notes, name }) => {
        const tag = name === 'fixed' ? tags[0] : tags.find((t) => t.startsWith(`${name}@`));
        /* istanbul ignore if */
        if (!tag) {
            return Promise.resolve();
        }
        const prereleaseParts = semver_1.default.prerelease(tag.replace(`${name}@`, '')) || [];
        const releaseOptions = {
            owner: repo.owner,
            repo: repo.name,
            tag_name: tag,
            name: tag,
            body: notes,
            draft: false,
            prerelease: prereleaseParts.length > 0,
        };
        if (gitDryRun) {
            npmlog_1.default.info('dry-run>', `Create Release with repo options: `, JSON.stringify(releaseOptions));
            return Promise.resolve();
        }
        return client.repos.createRelease(releaseOptions);
    }));
}
exports.createRelease = createRelease;
//# sourceMappingURL=create-release.js.map